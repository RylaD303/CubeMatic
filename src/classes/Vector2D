from typing import Union

number_types = Union[int, float, complex]

class Vector2D:
    def __init__(self, x : number_types, y : number_types) -> None:
        self.x = x
        self.y = y

    def __repr__(self) -> str:
        """returns: Unambiguous string representation of the vector."""
        return f"Vector2D({self._x, self._y})"

    def __str__(self) -> str:
        """returns: string representation of the vector."""
        return  f"{self._x, self._y}"

    def __add__(self, other : Union[number_types, "Vector2D"]) -> "Vector2D":
        if other is int or other is float or other is complex:
            return Vector2D(self._x + other, self._y + other)
        else:
            return Vector2D(self._x + other._x, self._y+other._y)

    def __radd__(self, other : Union[number_types, "Vector2D"]) -> "Vector2D":
        if other is int or other is float or other is complex:
            return Vector2D(self._x + other, self._y + other)
        else:
            return Vector2D(self._x + other._x, self._y+other._y)

    def __iadd__(self, other : "Vector2D") -> "Vector2D":
        self._x+=other._x
        self._y+=other._y
        return self


    def __mul__(self, other : Union[number_types, "Vector2D"]) -> Union[number_types,"Vector2D"]:
        if other is int or other is float or other is complex:
            return Vector2D(self._x*other, self._y*other)
        else:
            return self._x*other._x + self._y*other._y